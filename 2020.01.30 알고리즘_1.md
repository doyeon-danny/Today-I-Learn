# 알고리즘_1

### [ 알고리즘 ]

유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**

- 시작과 끝 반드시 존재!

- 표현 방법 크게 2가지

  - 슈더코드 ( pseudo code ) 

    문법이 따로 존재 X

    대부분의 알고리즘에서 선호하는 표현방법

  - 순서도

    그림

- 좋은 알고리즘 기준 : 정확성, 작업량, 최적성 ★

- 시간 복잡도 - 성능 기준

  - 빅-오 (O) 표기법 ☆

    일반적

    연산의 수를 계산 > 계수와 상수 제거, 최고차항만 남김

    O(logn) 이때 밑은 숫자 2

    O(1) O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)

  - 세타 표기법

    논문에서 주로 사용

  - 오메가 표기법

- 주요 해결 방법

  1.완전 검색 _ 모든 경우 탐색

  2. 그리디 
  3. 알고리즘분할 
  4. 정보다이나믹 프로그래밍 ( 동적 프로그래밍 )

  

### [ 배열 ]

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조 

- 자료형 ( Data types )

  - 정수형 ( integer, long )
  - 실수형 ( float, double )
  - 문자 ( char )

  **procedual language** - BASIC, C, PASCAL, FORTRAN

  **object-oriented language** - python, Java

  : procedual language 의기본자료형 + 객체 ( object ), 클라스 ( class )

- 필요성 : 하나의 선언으로 둘 이상의 변수 선언 가능

- *2차원 배열을 자유자재로 사용할 수 있으면 im 시험 통과*

- 2차원 배열

  num = [ [1,2], [3,4], [5,6] ] # 3행 2열



#### [ 배열 연습문제 1]

해결방법

1. 2차원 배열을 만들어서 상자가 있는 자리에는 1, 빈 공간에는 0을 배치한 뒤에 빈공간의 수 상자의 오른쪽 방향으로 0의 개수를 카운트해주어 구할 수 있다.

2. 가장 낙차가 큰 값을 원하기에 상자의 꼭대기의 값만 구하면 된다.

3. 상자 가장 높은 곳의 인데스만 가져와서 오른쪽방향으로 작은 값을 카운트해주면 된다.

    2차원 배열을 연산하는 과정을 생략할 수 있다.



#### [ baby-gin Game ]

해결방법

1. 완전 검색

   순열을 이용하여 모든 경우를 나열한 후 3장, 3장씩 나눠서 run, triplet 다 확인하면 된다. 

   - 순열 만드는 방법 _ 간단, 무식_ 비추

     ```python
     # {1, 2, 3}으로 모든 순열 구하기
     for i1 in range(1, 4):
         for i2 in range(1, 4):
             if i2 != i1:
                 for i3 in range(1, 4):
                     if i3 != i1 and i3 != i2:
                         print(i1, i2, i3)
     ```

2. 탐욕 ( Greedy ) 알고리즘

   : 최적해를 구하는 데 사용되는 근시안적 방법





































