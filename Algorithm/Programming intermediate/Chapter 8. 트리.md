# Chapter8. 트리

2020.04.16

### 트리

#### 개념

- 비선형 구조

- 그래프 + 연결 컴포넌트 (connected component) + `임의의 두 노드 사이에 유일한 경로가 존재`

  ▷ 싸이클 X , 노드 수 = 간선 수 + 1

- 원소들 간에 1:n 관계를 가지는 계층형 자료구조 (포함관계)

- 상위 원소에서 하위 원소로 내려가면서 확장되는 트리모양의 구조

#### 정의

- 한 개 이상의 노드로 이루어진 유한 집합
  - 노드 중 최상위 노드 : `루트(root)`
  - 나머지 노드들은 n(>=0)개의 **분리 집합**(서로소) T1, ...,TN으로 분리 될 수 있음.
  - 자식이 없는 노드 : `단말 노드`
- T1, .., TN은 각각 하나의 트리가 되며(재귀적 정의) 루트의 부 트리(subtree)라 함.

#### 용어정리

- 노드(node) : 트리의 원소 (n개)
- 간선(edge) : 노드를 연결하는 선, 부모 노드와 자식 노드를 연결 (n-1개, **노드수 - 1 개**)
- 루트 노드(root node) : 트리의 시작 노드, 부모 X
- 형제 노드(sibling node) : 같은 부모 노드의 자식 노드들
- 조상 노드 : 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들(한 노드를 기준)
  - 최소 공통조상(Lowest Common Ancestor, LCA) : 두 노드의 공통 조상을 봤을 때 가장 가까운 노드(루트 노드에서 가장 멀리 떨어진 노드)
- 서브 트리(subtree) : 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드 : 서브 트리에 있는 하위 레벨의 노드들
- 차수(degree) 
  - 노드의 차수 : 노드에 연결된 자식 노드의 수
  - 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
  - 단말 노드(리프 노드) : 차수가 0 인 노드, 자식 노드가 없는 노드
- 높이
  - 노드의 높이 : 루트에서 노드에 이르는 간선의 수, 노드의 레벨
  - 트리의 높이 : 트리에 있는 노드의 높이 중에서 가장 큰 값, 최대 레벨

### 이진 트리

- 모든 노드들이 최대 2개의 서브트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개 까지만 갖는 트리
  - 왼쪽 자식 노드 (left chlid node)
  - 오른쪽 자식 노드 (right child node)

#### 특징

- 레벨(높이) i에서의 노드의 최대 개수: 2^i 개
- 높이가 h인 이진 트리가 가질 수 있는 노드
  - 최소 개수 : h + 1 개
  - 최대 개수 : 2^(h+1)-1 개

#### 종류

##### 포화 이진 트리 (Full Binary Tree)

- 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리
- 높이가 h 일 때, 최대의 노드 개수인 (2^(h+1) - 1) 의 노드를 가진 이진 트리
- 루트를 1번으로 하여 (2^(h+1) - 1) 까지 정해진 위치에 대한 노드 번호를 가짐.
  - 왼쪽 노드들의 번호는 1, 2, 4, 8, ... 규칙을 가짐

##### 완전 이진 트리 (Complete Binary Tree) ★

- 높이가 h이고 노드 수가 n개 일 때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- 0 ~ h-1 높이는 다 차있고 마지막 높이에서 왼쪽 노드부터 순서대로 차있는 경우
- 배열로 구현하기 용이함!

##### 편향 이진 트리 (Skewed Binary Tree)

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
  - 왼쪽 편향 이진 트리
  - 오른쪽 편향 이진 트리

#### 순회 (traversal)

- 트리의 각 노드를 중복되지 않게 전부 방문하는 것
- 비 선형 구조이기 때문에 선형 구조와 같이 선후 연결 관계를 알 수 X
- 트리의 노드들을 체계적으로 방문하는 것

##### 기본적인 순회 방법

트리 순회시 방문 시점 3군데

모든 노드를 3번 지나간다.

처음 노드에 진입했을 때(전위 순위), 왼쪽 자식에서 돌아올 때(중위 순위), 오른쪽 자식에서 돌아올 때(후위 순위)

1. 전위 순위 (preorder traversal) : VLR

   - 부모 노드 방문 후, 자식 노드를 좌우 순서로 방문

2. 중위 순위 (inorder traversal) : LVR

   - 왼쪽 자식노드, 부모 노드, 오른쪽 자식 노드 순으로 방문

   ```python
   # 중위 순회 알고리즘
   def inorder_traverse(T): # 중위순위
       if T: # T is not None
           inorder_traverse(T.left)
           visit(T) # print(T.item)
           inorder_traverse(T.right)
   ```

3. 후위 순회 (postorder traversal) : LRV

   - 자식 노드를 좌우 순서로 방문한 후 부모 노드로 방문

##### 연습문제

![0416](https://user-images.githubusercontent.com/60081201/79417236-631bd800-7fec-11ea-8ff7-3cd0de030cbe.JPG)

- 전위 순위 : A (B(DHI)(EJ)) (C(FK)(GLM))
- 중위 순위 : HDIBJE A KFCLGM
- 후위 순위 : HIDJEB KFLMGC A

#### 표현

##### 1차 배열을 이용한 이진 트리의 표현

- 이진 트리에 각 노드 번호를 다음과 같이 부여
- 루트의 번호를 1로 함.
- 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n 부터 2^(n+1)-1까지 번호를 차례로 부여
- 노드 번호의 성질
  - 노드 번호가 i인 노드의 부모 노드 번호 : i/2
  - 노드 번호가 i인 노드의 왼쪽 자식 노드 번호 : 2*i
  - 노드 번호가 i인 노드의 오른쪽 자식 노드 번호 : 2*i + 1
  - 레벨 n의 노드 번호 시작 번호 : 2^n
- 노드 번호를 인덱스로 사용
- 완전 이진트리가 아닌 경우 메모리 낭비

##### 연결리스트

- 배열을 이용한 이진 트리의 표현 단점을 보완
- 이진 트리의 모든 노드는 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결 리스트 노드를 사용하여 구현 (단말노드는 왼쪽 오른쪽 null 값)

#### 연습문제

첫 줄에는 트리의 정점의 총 수 V가 주어진다. 그 다음 줄에는 V-1개 간선이 나열된다.

간선은 그것을 이루는 두 정점으로 표기된다. 간선으로 항상 "부모 자식" 순서로 표기한다.

아래 예에서 두 번째 줄 처음 1과 2는 점정 1과 2를 잇는 간선을 의미하며 1이 부모, 2가 자식을 의미한다.

간선은 부모 정점 번호가 작은 것부터 나열되고 부모 정점이 동일하다면 자식 정점 번호가 작은 것부터 나열된다.

```python
# 입력
# 13 # 정점의 개수, 간선의 수 : 12
# 1 2 1 3 2 4 3 5 3 6 4 7 5 8 5 9 6 10 6 11 7 12 11 13

V = int(input())
E = V - 1
arr = list(map(int, input().split()))
L = [0] * (V + 1) # 왼쪾
R = [0] * (V + 1) # 오른쪽
P = [0] * (V + 1) # 부모

for i in range(0, len(arr), 2):
    parent, child = arr[i], arr[i+1]
    if L[parent]: R[parent] = child
    else: L[parent] = child
    P[child] = parent

def inorder(v): # 방문하는 노드 번호
    if v == 0: return
    # 전위
    inorder(L[v])
    # 중위
    print(v, end=' ')
    inorder(R[v])
    # 후위
inorder(1)

# 출력
# 중위 : 12 7 4 2 1 8 5 9 3 10 6 13 11 
# cf) 전위 : 1 2 4 7 12 3 5 8 9 6 10 11 13
```

#### 수식 트리

- 수식을 표현하는 이진 트리
- 수식 이진 트리(Expression Binary Tree) 라 부르기도 함.
- 연산자는 루트 노드이거나 가지노드
- 피연산자는 모드 잎 노드(단말 노드)
- 후위 순회 (밑 가지 노드 연산자들의 중요성이 더 높기에, 밑에 있는 연산자 부터 계산)

### 이진탐색 트리

- 탐색작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 유일한 키를 가짐.
- key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
- 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리
- 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있다.

#### 탐색 연산

- 루트에서 시작

  - 탐색할 키 값 x를 루트 노드의 키 값과 비교
    - 키 값 x = 루트 노드의 키 값 : 원하는 원소를 찾았으므로 탐색 연산 성공
    - 키 값 x < 루트 노드의 키 값 : 루트 노드의 왼쪽 서브트리에 대해서 탐색 연산 수행
    - 키 값 x > 루트 노드의 키 값 : 루트 노드의 오른족 서브트리에 대해서 탐색 연산 수행

  - 서브트리에 대해서 순환적으로 탐색 연산을 반복!

#### 삽입 연산

트리의 높이만큼 (log n만큼 시간 걸림)

1. 먼저 탐색 연산을 수행
   - 삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없으므로, 같은 우너소가 트리에 있는지 탐색하여 확인
   - 탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 된다.
2. 탐색 실피한 위치에 원소를 삽입한다.

#### 삭제 연산

- 자식이 없는 경우(단일 노드일 경우) 부모 노드에 없앨 자식 노드 null로 만든다.
- 자식이 있는 경우 연결해야 한다.
- 루트를 없앨 경우 왼쪽 서브트리의 가장 큰값이나 오른쪽 서브트리의 가장 작은 값으로 루트 설정

#### 성능

- 탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸린다. O(h) (h: BSF 깊이)
- 평균의 경우 : 이진 트리가 균형적으로 생성되어 있는 경우 O(log n)
- 최악의 경우
  - 한쪽으로 치우친 경사 이진 트리의 경우
  - O(n)
  - 순차 탐색과 시간 복잡도 동일

### 힙 (heap) - 참고

- 우선 순위 큐

- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료 구조
- 최대 힙 (max heap)
  -  키값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - 부모 노드의 키값 > 자식 노드의 키값
  - 루트 노드 : 키값이 가장 큰 노드
- 최소 힙 (min heap)
  - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - 부모 노드의 키값 < 자식 노드의 키 값
  - 루트 노드 : 키값이 가장 작은 노드

#### 삽입 연산

- 마지막에 삽입한 후에 부모 노드와 비교하여 자리를 바꾸는 것을 반복하고 바꿀 필요 없으면 자리 확정한다.

#### 삭제 연산

- 힙에서는 루트 노드의 원소만을 삭제 가능하다.
- 루트 노드의 원소를 삭제하여 반환하다.
- 힙의 종류에 따라 최대값 또는 최솟값 구할 수 있다.

- 방법
  - 원소는 원소를 삭제하고 마지막 노드의 값을 삭제한 원소 값에 넣어준다.
  - 마지막 가리키는 번호 1을 줄여준다.
  - 규칙을 만족할 때까지 자리를 바꾸고 이후에 자리를 확정한다.

#### 힙을 이용한 우선순위 큐 (참고)

- 다익스 알고리즘

