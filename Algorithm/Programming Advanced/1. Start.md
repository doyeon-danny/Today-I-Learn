# 1. Start

2020.04.29

### SW 문제 해결

#### 알고리즘의 중요성

- 광범위한 분야의 알고리즘 적용
- 새로운 도전의 기회 제공
- 다른 방식으로는 풀 수 없는 문제의 해결 방법 제시
- computational 모델이 타 영역에서 수학적 모델을 대체하는 추세
- 유능한 프로그래머가 되기 위한 방법

#### 프로그래밍하기 위한 제약 조건과 요구사항

- 프로그래밍 언어의 특성
- 라이브러리들의 유의 사항
- 프로그램이 동작할 HW와 OS에 관한 지식
- 프로그램이 사용할 수 있는 최대 메모리
- 사용자 대응 시간 제한
- 재사용성이 높은 간결한 코드

#### SW 문제 해결 역량이란?

- 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 연결하여 만드는 능력
- 문제 해결 역량 = 추상적인 기술
  - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체 X
  - 알고리즘을 암기하고 문제를 푼다고 향상되지 X
  - 문제 해결 역량을 향상하기 위해서 훈련 필요

#### 문제 해결 능력을 훈련하기 위해서

- 일부 새로운 언어, 프레임워크, 개발 방법론들을 조합해 나가는 방법을 배워야 한다.

- 상황을 인위적으로 만들어 훈련해야 한다.

  잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상시킬 수 있는 훈련이 필요하다.

#### 문제 해결 과정

1. 문제의 모델링
   - 문제 일고 이해 => 문제를 익숙한 용어로 재정의
2. 문제를 해결할 알고리즘 찾기
   - 어떻게 해결할지 계획
3. 알리고즘의 검증
   - 충분한 성능과 적절한 메모리 사용에 대한 검증
4. 프로그램으로 구현
5. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 탐색

- 문제 해결 전략
  - 직관적인 접근
  - 체계적인 접근
    - 비슷한 문제를 풀어본 적 있는가
    - 단순한 방법에서 시작가능한가
    - 문제를 단순화 가능한가
    - 그림으로/수식으로 표현 가능한가
    - 문제를 분해 가능한가
    - 뒤에서 생각해서 문제를 풀 수 있는가
    - 특정 현태의 답만을 고려할 수 있는가

### 복잡도 분석

#### 알고리즘 

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

주로 컴퓨터 용어로 쓰이며 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함

=> 어떠한 문제를 해결하기 위한 절차

#### 알고리즘 효율성

- 공간적 효율성과 시간적 효율성
  - 공간적 효율성 : 얼마나 많은 메모리 공간을 요하는가 "RAM 사용량"
  - 시간적 효율성 : 얼마나 많은 시간을 요하는가 "CPU 사용량"
  - 효율성을 뒤집어 표현하면 복잡도가 된다. 복잡도가 높을수록 효율성은 저하된다.
- 시간 복잡도 분석
  - 하드웨어 환경에 따라 처리시간 달라짐
  - 소프트웨어 환경에 따라 처리시간 달라짐

#### 복잡도 분석

- 점근적 표기(Asymptotic Notation)를 사용
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법

##### O(Big-Oh)-표기 "최악의 경우"

- T(n) : 실행시간
- n0보다 크거나 같은 모든 n에 대해서
- T(n) <= c * f(n) 이 되는 상수 c, n0가 존재할 때만 T(n) = O(f(n)) 이라 한다.
- 단, 상수 c와 초기값 n0 는 n의 값에 독립적이다.
- O - 표기는 복잡도의 점근적 상한을 나타냄

##### Ω (Big-Omega) - 표기 "최상의 경우"

- T(n) : 실행시간
- n0보다 크거나 같은 모든 n에 대해서
- T(n) >= c * f(n) 이 되는 상수 c, n0가 존재할 때만 T(n) = Ω (f(n)) 이라 한다.
- 단, 상수 c와 초기값 n0 는 n의 값에 독립적이다.
- 복잡도의 점근적 하한을 나타냄
- O-표기와 마찬가지로 오메가-표기도 복잡도 다항식의 최고차항만 계수 없이 취하면 된다.
  - 최소한 이만한 시간은 걸린다!

##### Θ (Theta) - 표기 "평균의 경우"

- T(n) = O(f(n))이고 T(n) = Ω(f(n)) 일 때 T(n) = Θf(n)) 이 성립한다.
- T(n) : 실행시간
- n0보다 크거나 같은 모든 n에 대해서
- c1 * f(n) <= T(n) <= c2 * f(n)이 되는 상수 c1, c2, n0가 존재할 때만 T(n) = Θ(f(n)) 이라 한다.
- Ω <= Θ<= O

#### 문제

- T(n) = 1/2 * n^2 + 3n 인 알고리즘의 시간 복잡도로 맞는 것을 모두 고르시오
  1. T(n) = O(n)
  2. T(n) = Ω(n), n0 = 1, c = 1/2
  3. T(n) = Θ(n^2), n0 = 1, c1 = 1/2, c2 = 4
  4. T(n) = O(n^3), n0 = 1, c = 4

- 정답: 2, 3, 4

- 풀이

  n : 입력데이터의 개수 => 자연수

  1. 1/2 * n^2 + 3n <= cn

     n^2 + 6n <= 2cn

     n(n + 6 -2c) <= 0

     n < 2c -6

  2. 1/2 * n^2 + 3n >= 1/2 * n

     n^2 + 5n >=0

     n(n + 5) >= 0

  3. 1/2 * n^2 <= 1/2 * n^2 + 3n <= 4n^2

  4. 1/2 * n^2 + 3n >= 4n^3

     n^2 + 6n >= 8n^3

     n(8n^2 - n - 6) >= 0

#### 자주 사용하는 O-표기

|  O-표기  |                             시간                             |
| :------: | :----------------------------------------------------------: |
|   O(1)   | 상수 시간 (Constant time)<br />입력자료의 수에 관계없이 일정한 실행시간을 가짐. |
| O(logn)  | 로그(대수) 시간 (Logarithmic time)<br />보통 전체를 일정한 크기로 나눌 경우 나타남. |
|   O(n)   |                   선형 시간 (Linear time)                    |
| O(nlogn) | 로그 선형 시간 (Log-linear time)<br />전체를 독립적으로 나누어진 뒤 마지막에 하나로 모아주는 경우 나타남. |
|  O(n^2)  | 제곱 시간 (Quadratic time)<br />이중 루트 내에서 자료를 처리하는 경우 나타남. |
|  O(n^3)  | 세제곱 시간 (Cubit time)<br />삼중 루프 내에서 처리하는 경우 나타남. |
|  O(2^n)  |                 지수 시간 (Exponential time)                 |

- 효율적인 알고리즘은 값비싼 하드웨어의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.

### 표준 입출력 방식

#### python 표준 입출력

- 입력

  - Raw 값의 입력 : input()

    입력받은 값을 문자열로 처리

  - Evaluated 된 값 입력 : eval(input())

    받은 입력값을 평가된 데이터 형으로 처리

- 출력

  - print() : 표준출력함수, 출력값의 마지막에 개행문자 포함
  - print("text", end="") : 출력시 마지막에 개행문자 제외
  - print("%d" %number) : 포맷된 출력

#### 파일의 내용을 표준 입력으로 읽어오는 방법

```python
import sys

sys.stdin = open("input.txt", "r")
sys.stdout = open("output.txt", "w")

text = input()
print(text)
```

### 비트 연산

#### 비트 연산자

| 연산자 |                  연산자의 기능                  |    예    |
| :----: | :---------------------------------------------: | :------: |
|  `&`   |               비트단위로 AND 연산               | n1 & n2  |
|  `|`   |               비트 단위로 OR 연산               | n1 \| n2 |
|  `^`   |  비트 단위로 XOR 연산<br />같으면 0, 다르면 1   | n1 ^ n2  |
|  `~`   | 단항 연산자로서 피연산자의 모든 비트를 반전시킴 |   ~ n1   |
|  `<<`  |      피연산자의 비트열을 왼쪽으로 이동시킴      | n1 << 2  |
|  `>>`  |     피연산자의 비트열을 오른쪽으로 이동시킴     | n1 >> 2  |

- `N & 1`
  - 변수에 저장된 양의 정수 값의 홀수 짝수 판별 => `N % 2`
  - & 연산으로 마지막 비트 값이 1인지 0인지 판단, 짝수 홀수 판별

- `1 << n`
  - 2^n 의 값
  - 원소가 n개일 경우 모든 부분집합의 수 의미
  - Power set(모든 부분 집합)
    - 공집합과 자신을 포함한 모든 부분집합
    - 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산된다.

- `i & (1 << j) = (i >> j) & 1`
  - 계산 결과는 i의 j번째 비트가 1인지 아닌지 의미

#### 비트 연산 예제1

```python
def Bbit_print(i):
    output = ''
    for j in range(7, -1, -1):
        output += "1" if i & (1<<j) else "0"
        # print('1' if (i&(1<<j)) else '0', end='') # 위의 코드와 동일한 동작
    print(output)


for i in range(-5, 6):
    print("{} = ".format(i), end='')
    Bbit_print(i)
```

```markdown
출력값
-5 = 11111011
-4 = 11111100
-3 = 11111101
-2 = 11111110
-1 = 11111111
0 = 00000000
1 = 00000001
2 = 00000010
3 = 00000011
4 = 00000100
5 = 00000101
```

#### 연습문제 1

- 0과 1로 이뤄진 1차 배열에서 7개 byte를 묶어서 10진수로 출력하기

- 예를들어 `00000010001101` 이면 1, 13을 출력한다.

- 입력 예

  - 0000000111 1000000110 0000011110 0110000110 0001111001 111001111 1001100111
  - 편의상 10개 단위로 간격을 두었음. 이어있는 데이터로 간주하시오.

- 풀이

  ```python
  # solution 1
  
  inp = input()
  for i in range(0, len(inp), 7):
      cnt = res = 0
      while j < len(inp) and cnt < 7:
          res = res * 2 + int(input[j])
          cnt += 1
          j += 1
      print(res, end='')
  ```

  ```python
  # solution 2
  
  inp = input()
  for i in range(0, len(inp), 7):
      res = 0
      for j in range(i, 7):
          res = res * 2 + int(input[j])
      print(res, end='')
  ```

  - 출력 : 0 120 12 7 76 24 60 121 124 103

#### 엔디안(Endianness)

- 컴퓨터의 메모리와 같은 1차원 공간에 여러개의 연속된 대상을 배열하는 방법을 의미, HW 아키텍처마다 다름

- 주의 : 속도 향상을 위해 바이트 단위와 워드(컴퓨터가 한번에 처리하는) 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류 발생

  ex) 32bit OS, 64bit Os 여기서 bit가 워드를 의미!

  1byte = 8bit

  - 빅엔디안 (Big-endian)

    보통 큰 단위가 앞에 나옴

    네트워크 (internet protocol, IBM z/architecture, motorla chipset)

  - 리틀 엔디안 (Little-endian)

    작은 단위가 앞에 나옴

    대다수 데스크탑 컴퓨터 (Intel, ARM processor)

    |    종류     | 0x1234의 표현 | 0x12345678의 표현 |
    | :---------: | :-----------: | :---------------: |
    |  빅 엔디안  |     12 34     |    12 34 56 78    |
    | 리틀 엔디안 |     34 12     |    78 56 34 12    |

#### 비트 연산 예제

##### 엔디안 확인 코드

```python
# solution 1
# 비트 연산을 확인하여 엔디안을 확인하는 방법

n = 0x00111111

if n & 0xff:
    print("little endian")
else:
    print("big endian")
```

```python
# solution 2
# 파이썬 시스템 라이브러리에서 제공하는 방법

import sys

if sys.byteorder == "little":
    print("Little endian platform")
else:
    print("Big endian platform")
```

##### 엔디안 변환 코드

```python
# solution 1

def ce(n):
    p = []
    for i in range(0, 4):
        p.append(n>>(24 - i*8) & 0xff)
    return p

# solution 2
def ce1(n):
    return (n<<24 & oxff000000) | (n<<8 & 0xff0000) | (n>>8 & 0xff00) | (n>>24 & 0xff)
```

```python
x = 0x01020304
p = []

for i in range(0, 4):
    p.append(x>>(i*8) & 0xff)

print("x={}{}{}{}".format(p[0],p[1],p[2],p[3]))
p = ce(x)
print("x={}{}{}{}".format(p[0],p[1],p[2],p[3]))
```

##### python에서 엔디안 변환

```python
import struct

num = 27
print(bin(num))
res = struct.pack('i', num)
print("default:",res)

res = struct.pack('>i',num)
print("big endian:",res)

res = struct.pack('<i',num)
print("little endian:",res)

res = struct.pack('! i',num)
print("network:",res)
print("unpack:",struct.unpack('!i',res)) # 결과값 풀어서 볼 경우 unpack이용
```

```markdown
실행 결과
0b11011
default: b'\x1b\x00\x00\x00'
big endian: b'\x00\x00\x00\x1b'
little endian:b'\x1b\x00\x00\x00'
network: b'\x00\x00\x00\x1b'
unpack:(27,)
```

##### 비트 연산자 ^

- 두번 연산하면 처음 값을 반환한다.

- 다르면 1, 같으면 0

```python
def BitPrint(i):
    for j inm range(7, -1, -1):
        print('%d' %((i>>j)&1), end='')
    print()
    
a = 0x86
key = 0xAA

print("a -> ", end='')
BitPrint(a)

print("a^key =>", end='')
a ^= key
BitPrint(a)

print("a^key =>",end='')
a ^= key
BitPrint(a)
```

```markdown
출력값
a -> 10000110
a^key -> 00101100
a^key -> 10000110
```

### 진수

#### 진수 변환

- 2진수, 8진수, 10진수, 16진수
- 10진수 -> 타진수 변환
  - 원하는 타 진법의 수로 나눈 뒤 나머지를 거꾸로 읽는다.
  - ex) 149 (10진수) = 10010101 (2진수) = 225 (8진수) = 95 (16진수)
- 2진수, 8진수, 16진수간 변환
  - 2진수 -> 8진수 (뒤에서 부터 3개씩 묶어서 계산해주면 된다!)
  - 2진수 -> 16진수 (뒤에서 부터 4개씩 묶어서 계산해주면 된다!)

#### 컴퓨터에서의 음의 정수 표현 방법

- 1의 보수 : 부호와 절댓값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0으로 변환한다. `"비트 반전"`

- 2의 보수 :star: : 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더한다. `"1의 보수 + 1"`

- 4 비트 예

  | 10진수 | 2진수 절댓값 | 부호 + 절댓값  |    1의 보수    | 2의 보수 |
  | :----: | :----------: | :------------: | :------------: | :------: |
  |   0    |     000      | 0000<br />1000 | 0000<br />1111 |   0000   |
  |   -1   |     001      |      1001      |      1110      |   1111   |
  |   -2   |     010      |      1010      |      1101      |   1110   |
  |   -3   |     011      |      1011      |      1100      |   1101   |
  |   -4   |     100      |      1100      |      1011      |   1100   |
  |   -5   |     101      |      1101      |      1010      |   1011   |
  |   -6   |     110      |      1110      |      1001      |   1010   |
  |   -7   |     111      |      1111      |      1000      |   1001   |

  - 1의 보수는 발생한 캐리값 다시 더해주기
  - 2의 보수에서 발생한 캐리는 버리기
  - ex) 4 - 3
    - 1의 보수 : = 0100 + 0101 = 1 0000 = 0001 
    - 2의 보수 : = 0100 + 1101 = 1 0001 = 0001

#### 연습문제 2

- 16진수 문자로 이루어진 1차 배열이 주어질 때 앞에서부터 7bit씩 묶어 십진수로 변환하여 출력해 보자
- 예를 들어 0F97A3 일 경우0000 1111 1001 0111 1010 0011 -> 0000111 1100101 1110100 011 로 나눠서 7, 101, 116, 3을 출력한다.
- 입력 예 : 01D06079861D79F99F

- 풀이 1

  - dictionary 이용

    ```python
    def convert1(num):
        h2b = {
            '0':'0000', # 16진수 문자: 2진수 문자열
            '1':'0001',
            '2':'0010',
            '3':'0011',
            '4':'0100',
            '5':'0101',
            '6':'0110',
            '7':'0111',
            '8':'1000',
            '9':'1001',
            'A':'1010',
            'B':'1011',
            'C':'1100',
            'D':'1101',
            'E':'1110',
            'F':'1111',
            'a':'1010',
            'b':'1011',
            'c':'1100',
            'd':'1101',
            'e':'1110',
            'f':'1111',
        }
        return h2b.get(num)
    ```

- 풀이 2

  - if 숫자 문자: int()

  - else: ord(ch) - ord('A') + 10

    ```python
    def convert(num): #16진수 문자
        # 16진수 -> 10진수로 변환
        if num.isdigit():
            num = int(num)
        else:
            num = 10 + ord(num.upper()) - ord('A')
        # sol 1) 10진수 -> 2진수 문자열로 변환
        temp = ''
        for j in range(3, -1, -1):
            temp += '1' if (num&(1<<j)) else '0'
        # sol 2) 10진수 -> 2진수 문자열로 변환
        t = [0] * 4
        for j in range(4):
            t[3-j] = str((num >> j) & 1)
        print(''.join(t))
        return temp
    
    hex = input()
    bin = ''
    for i in range(len(hex)):
        tmp = convert(hex[i])
        # tmp = convert1(hex[i])
        bin += tmp
    print(bin)
    
    for i in range(0, len(bin), 7):
        dec = 0
        try:
            for j in range(7):
                dec = dec*2 + int(bin[i+j])
        except:
            pass
        print(dec, end=" ")
    ```

### 실수

#### 실수의 표현

- 소수점 이하 4자리를 10진수로 나타낸 표

  | 2진수  | 10진수 값       |
  | :----: | --------------- |
  | 0.0000 | 0               |
  | 0.0001 | 0.0625 = 2^(-4) |
  | 0.0010 | 0.125 = 2^(-3)  |
  | 0.0011 | 0.1875          |
  | 0.0100 | 0.25 = 2^(-2)   |
  | 0.0101 | 0.3125          |
  | 0.0110 | 0.375           |
  | 0.0111 | 0.4375          |
  | 0.1000 | 0.5 = 2^(-1)    |
  | 0.1001 | 0.5625          |
  | 0.1010 | 0.625           |
  | 0.1011 | 0.6875          |
  | 0.1100 | 0.75            |
  | 0.1101 | 0.8125          |
  | 0.1110 | 0.874           |
  | 0.1111 | 0.9375          |

- 2진 실수를 10진수로 변환하는 방법

  - ex) 1001.0011

    1 X 2^(-4) = 0.0625

    1 X 2^(-3) = 0.125

    0 X 2^(-2) = 0.25

    0 X 2^(-1) = 0.5

    1 X 2^(0) = 1

    0 X 2^(1) = 0

    0 X 2^(2) = 0

    1 X 2^(3) = 8 => 결과 다합한 : 9.1875

#### 부동 소수점

- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용한다.

  - cf) 고정 소수점 (fixed-point)

    잘 사용되지 않음, 앞 비트에 부호를 표현하고 실수를 표현하는 방식

    부동소수점에 비해 표현 자리수가 적기 때문에 정확도 떨어짐(오차 범위 커짐)

- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식이다.

  - 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현

  - ex) 1001.0011 -> 1.0010011 * 2^3

  - ex2) 0.0010110 -> 1.0110 * 2^(-3)

  - 1이 제일 앞에 항상 나오도록!!! 

    따라서 1은 저장안해도되기에 소숫점 아래 부분이랑 지수 부분을 저장한다.

#### 실수를 저장하기 위한 형식

- 단정도 실수 (32bit)

  - C, java에서 float 
  - 단정도 실수 : `부호 1비트 + 지수 8비트 + 기수 32비트`

- 배정도 실수 (64bit)

  - C, java에서 double
  - python에서 float이라 불림
  - 배정도 실수 : `부호 1비트 + 지수 11비트 + 가수 52비트`
  - 단정도 실수와 비교
    - 지수부 : 표현할 수 있는 수의 범위 넓음
    - 가수부 : 비트가 더 크기에 값을 정밀하게 표현 가능

  [참고 개념]

  기수부 (mantissa) : 실수의 유효 자릿수들을 고정 소수점으로 표현한 것

  지수부 (exponent) : 실제 소수점의 위치를 지수 승으로 표현한 것

#### 단정도 실수의 가수 부분을 만드는 방법

- ex) 1001.0011

  - 정수부의 첫 번재 자리가 1이 되도록 오른쪽으로 시프트

  - 소수점 이하를 23비트로 만든다.

  - 소수점 이하만을 기수 부분에 저장

  - 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소

    0001.0010011

    0001.00100110000000000000000

    00100110000000000000000

- 지수부에는 8비트가 배정 (256개의 상태를 나타낼 수 있음)
- 숫자로는 0 ~ 255까지 나타낼 수 있지만 음수값을 나타낼 수 있어야 하므로 `익세스(excess) 표현법`을 사용
  
  - 익세스(excess) 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

#### 단정도 표현에서의 지수부 익세스 표현

| 실제 지수 |   2진수   | 10진수 값 |
| :-------: | :-------: | :-------: |
|    128    | 11111111  |    255    |
|    127    | 11111110  |    254    |
|    ...    |           |           |
|     3     | 10000010  |    130    |
|     2     | 10000001  |    129    |
|     1     | 10000000  |    128    |
|     0     | 01111111  |    127    |
|    -1     | 011111110 |    126    |
|    ...    |           |           |
|   -126    | 00000001  |     1     |
|   -127    | 00000000  |     0     |

- ex) 1001.0011 을 단정도 실수로 표현한 예

  0 | 10000010 | 00100110000000000000000

  1.0010011 X 2^3

- 지수부의 음수양수표현은 excess 표현법 사용

#### 실수

- 컴퓨터는 실수를 근사적으로 표현한다.

  - 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 `근사값`으로 저장되는데 이때 생기는 작은 `오차`가 계산 과정에서 다른 결과를 가져온다.

- 실수 자료형의 유효 자릿수를 알아 두자

  - 32비트 실수형 유효자릿수(십진수 기준) -> 6

  - 64비트 실수형 유효자릿수(십진수 기준) -> 15

    소숫점 아래 6/15자리까지 표현되고 그 값을 넘어가면 오차 발생 가능!

#### 연습문제 3

- 16진수 문자로 이루어진 1차 배열이 주어질 때 암호 비트 패턴을 찾아 차례대로 출력하시오. 암호는 연속되어있다.

  [암호비트 패턴]

  |   0    |   1    |   2    |   3    |   4    |   5    |   6    |   7    |   8    |   9    |
  | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
  | 001101 | 010011 | 111011 | 110001 | 100011 | 110111 | 001011 | 111101 | 011001 | 101111 |

- 예를 들어 0DEC인 경우

  - 00 001101 111011 00
  - 0, 2가 출력된다.

- 입력 예 : 0269FAC9A0

  - 풀이

    암호비트 패턴 : 모두 6자리, 뒤에 1이 있음.

    ```python
    arr = '0269FAC9A0'
    # 16진수를 2진수로 변환
    arr = arr.replace('0','0000')
    arr = arr.replace('1','0001')
    arr = arr.replace('2','0010')
    arr = arr.replace('3','0011')
    arr = arr.replace('4','0100')
    arr = arr.replace('5','0101')
    arr = arr.replace('6','0110')
    arr = arr.replace('7','0111')
    arr = arr.replace('8','1000')
    arr = arr.replace('9','1001')
    arr = arr.replace('A','1010')
    arr = arr.replace('B','1011')
    arr = arr.replace('C','1100')
    arr = arr.replace('D','1101')
    arr = arr.replace('E','1110')
    arr = arr.replace('F','1111')
    
    # arr : 2진수 변환된 문자열
    patt = ['001101', '010011', '111011', '110001',
            '100011', '110111', '001011', '111101',
            '011001', '101111']
    for i in range(len(arr)-6):
        if arr[i:i+6] in patt:
            x = patt.index(arr[i:i+6])
            break
    
    print(arr)
    for i in range(arr.index(patt[x]), len(arr)-6, 6):
        print(patt.index(arr[i:i+6]), end=' ')
    ```

    ```markdown
    출력값
    0000001001101001111110101100100110100000
    1 1 7 8 0 
    ```

  - 풀이 2

    ```python
    # 16진수 문자 -> 10진수 정수로 변환
    def convert(ch):
        if ch.isdigit():
            return int(ch)
        else:
            return 10 + ord(ch.upper()) - ord('A')
    
    # 10진수 정수 -> 4자리 비트 문자열로 변환
    inp = '0269FAC9A0'
    bin = ''
    for i in range(len(inp)):
        tmp = convert(inp[i])
        for j in range(3, -1, -1):
            bin += '1' if tmp & (1<<j) else '0'
    
    print(bin) # 0000001001101001111110101100100110100000
    
    pattern = [13, 19, 59, 49, 35, 55, 11, 61, 25, 47]
    p = len(bin) - 1
    res = [""] * len(inp)
    ridx = 0
    while p > 4:
        if bin[p] == '0': # 뒤에서 부터 읽는데 0이면 스킵
            # 암호패턴 끝값은 1이기 때문
            p -= 1
            continue
        # 6bits 를 10 진수 정수값으로 변환
        dec = 0
        for j in range(5, -1, -1):
            dec = dec*2 + int(bin[p-j])
        # 6 bits 암호 비트 맞는지 찾기
        if dec in pattern:
            res[ridx] = pattern.index(dec)
            ridx += 1
            p -= 6
        else:
            p -= 1
    print(" ".join(str(res[i]) for i in range(ridx, -1, -1))) # 뒤에서 부터 찾았기 때문
    ```

    ```markdown
    출력값
    0000001001101001111110101100100110100000
     1 1 7 8 0
    ```

  - 풀이 3

    ```python
    def convert(ch):
        if ch.isdigit():
            return int(ch)
        else:
            return 10 + ord(ch.upper()) - ord('A')
        
    inp = '0269FAC9A0'
    bin = ''
    for i in range(len(inp)):
        tmp = convert(inp[i])
        for j in range(3, -1, -1):
            bin += '1' if tmp & (1<<j) else '0'
            
    # 연속된 숫자의 개수 0 1 0 1 순으로!
    pwd = [[[[""]*5 for _ in range(5)] for _ in range(5)] for _ in range(5)]
    pwd[2][2][1][1] = 0
    pwd[1][1][2][2] = 1
    pwd[0][3][1][2] = 2
    pwd[0][2][3][1] = 3
    pwd[0][1][3][2] = 4
    pwd[0][2][1][3] = 5
    pwd[2][1][1][2] = 6
    pwd[0][4][1][1] = 7
    pwd[1][2][2][1] = 8
    pwd[0][1][1][4] = 9
    
    p = len(bin) -1
    res = [""] * p
    ridx = 0
    while p > 4:
        if bin[p] == '0':
            p -= 1
            continue
        chk = [0] * 4
        cnt = 5
        for i in range(4):
            while i&1 == int(bin[p-cnt])&1:
                chk[i] += 1
                cnt -= 1
                if cnt < 0:
                    break
        res[ridx] = pwd[chk[0]][chk[1]][chk[2]][chk[3]]
        if res[ridx] != None:
            ridx += 1
            p -= 6
        else:
            p -= 1
    print(" ".join(str(res[i]) for i in range(ridx, -1, -1))) # 출력 : 1 1 7 8 0
    ```

### + 파이썬의 숫자 자료형

#### 정수형

- python 3.x부터 정수형 데이터의 최댓값은 정의되지 않았고,  정수형 자료의 표현 범위에 제한이 없다.

- 2진수, 8진수, 16진수 표현 : 0b~, 0o~, 0x~ 로 나타낸다.

  ```python
  b1 = 0b1010
  o1 = 0o327
  h1 = 0xab9
  print(b1, o1, h1) # 출력값 : 10 215 2745
  ```

#### 파이썬의 음수 나눗셈 연산 

- `//` : 정수 나눗셈 연산자, 소수점 아래에 대해서 floor() 처리

- `%` : 나머지 연산자, 나누는 수(젯수)의 부호에 따름!

- a/b 의 몫 p, 나머지 r 이라 할 때

  a = b * q + r , 0 <= |r| < b 가 성립된다.

#### 파이썬의 음수 나눗셈 연산 :cactus:

```python
for n in range(-8, 9):
    print("%3d%4d%4d%5d%5d" %(n,n//4,n%4,n//-4,n%4))
```

```markdown
실행 결과
 -8  -2   0    2    0
 -7  -2   1    1    1
 -6  -2   2    1    2
 -5  -2   3    1    3
 -4  -1   0    1    0
 -3  -1   1    0    1
 -2  -1   2    0    2
 -1  -1   3    0    3
  0   0   0    0    0
  1   0   1   -1    1
  2   0   2   -1    2
  3   0   3   -1    3
  4   1   0   -1    0
  5   1   1   -2    1
  6   1   2   -2    2
  7   1   3   -2    3
  8   2   0   -2    0
```

#### 실수형

- C, Java의 경우, float과 double 형이 있지만, 파이썬의 경우는 C, Java의 double에 해당되는 실수형만 존재한다.

- 최대로 표현할 수 있는 범위 : (+/-)1.8 X 10^308 이고 이 이상은 Inf/-inf로  표현

- 최소로 표현할 수 있는 범위 : (+/-)2.2 X 10^-308이고 무한소는 0으로 표현

  (파이썬 3.7 기준)

  ```python
  print(1e310, -1e310, 1e-324) # 출력값 : inf -inf 0.0
  ```

##### 실수의 오차

```python
print(0.1+0.2) # 0.30000000000000004
print(0.1+0.2==0.3) # False
print('0.1=%.55f'%0.1) # 0.1=0.1000000000000000055511151231257827021181583404541015625
print('0.2=%.55f'%0.2) # 0.2=0.2000000000000000111022302462515654042363166809082031250
print('0.3=%.55f'%0.3) # 0.3=0.2999999999999999888977697537484345957636833190917968750
```

#### 복소수형

- 복소수형 자료는 실수부(.real)와 허수부(.img)로 나뉘며 실수부와 허수부는 각각 실수형으로 저장된다.
- 허수부 숫자 뒤에 i또는 j를 붙여 허수부임을 표시한다.

```python
a = 1 -3j
print(a.real, a.imag) # 1.0 -3.0
```

