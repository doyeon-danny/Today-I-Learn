# 1. Start

2020.04.29

### SW 문제 해결

#### 알고리즘의 중요성

- 광범위한 분야의 알고리즘 적용
- 새로운 도전의 기회 제공
- 다른 방식으로는 풀 수 없는 문제의 해결 방법 제시
- computational 모델이 타 영역에서 수학적 모델을 대체하는 추세
- 유능한 프로그래머가 되기 위한 방법

#### 프로그래밍하기 위한 제약 조건과 요구사항

- 프로그래밍 언어의 특성
- 라이브러리들의 유의 사항
- 프로그램이 동작할 HW와 OS에 관한 지식
- 프로그램이 사용할 수 있는 최대 메모리
- 사용자 대응 시간 제한
- 재사용성이 높은 간결한 코드

#### SW 문제 해결 역량이란?

- 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 연결하여 만드는 능력
- 문제 해결 역량 = 추상적인 기술
  - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체 X
  - 알고리즘을 암기하고 문제를 푼다고 향상되지 X
  - 문제 해결 역량을 향상하기 위해서 훈련 필요

#### 문제 해결 능력을 훈련하기 위해서

- 일부 새로운 언어, 프레임워크, 개발 방법론들을 조합해 나가는 방법을 배워야 한다.

- 상황을 인위적으로 만들어 훈련해야 한다.

  잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상시킬 수 있는 훈련이 필요하다.

#### 문제 해결 과정

1. 문제의 모델링
   - 문제 일고 이해 => 문제를 익숙한 용어로 재정의
2. 문제를 해결할 알고리즘 찾기
   - 어떻게 해결할지 계획
3. 알리고즘의 검증
   - 충분한 성능과 적절한 메모리 사용에 대한 검증
4. 프로그램으로 구현
5. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 탐색

- 문제 해결 전략
  - 직관적인 접근
  - 체계적인 접근
    - 비슷한 문제를 풀어본 적 있는가
    - 단순한 방법에서 시작가능한가
    - 문제를 단순화 가능한가
    - 그림으로/수식으로 표현 가능한가
    - 문제를 분해 가능한가
    - 뒤에서 생각해서 문제를 풀 수 있는가
    - 특정 현태의 답만을 고려할 수 있는가

### 복잡도 분석

#### 알고리즘 

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

주로 컴퓨터 용어로 쓰이며 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함

=> 어떠한 문제를 해결하기 위한 절차

#### 알고리즘 효율성

- 공간적 효율성과 시간적 효율성
  - 공간적 효율성 : 얼마나 많은 메모리 공간을 요하는가
  - 시간적 효율성 : 얼마나 많은 시간을 요하는가
  - 효율성을 뒤집어 표현하면 복잡도가 된다. 복잡도가 높을수록 효율성은 저하된다.
- 시간 복잡도 분석
  - 하드웨어 환경에 따라 처리시간 달라짐
  - 소프트웨어 환경에 따라 처리시간 달라짐

#### 복잡도 분석

- 점근적 표기(Asymptotic Notation)를 사용
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법

##### O(Big-Oh)-표기

- T(n) : 실행시간
- n0보다 크거나 같은 모든 n에 대해서
- T(n) <= c * f(n) 이 되는 상수 c, n0가 존재할 때만 T(n) = O(f(n)) 이라 한다.
- 단, 상수 c와 초기값 n0 는 n의 값에 독립적이다.
- O - 표기는 복잡도의 점근적 상한을 나타냄

##### Big-Omega - 표기

- T(n) : 실행시간
- n0보다 크거나 같은 모든 n에 대해서
- T(n) >= c * f(n) 이 되는 상수 c, n0가 존재할 때만 T(n) = 오메가(f(n)) 이라 한다.
- 단, 상수 c와 초기값 n0 는 n의 값에 독립적이다.
- 복잡도의 점근적 하한을 나타냄
- O-표기와 마찬가지로 오메가-표기도 복잡도 다항식의 최고차항만 계수 없이 취하면 된다.
  - 최소한 이만한 시간은 걸린다!

##### Theta - 표기

- T(n) = O(f(n))이고 T(n) = 오메가(f(n)) 일 때 T(n) = 세타(f(n)) 이 성립한다.
- T(n) : 실행시간
- n0보다 크거나 같은 모든 n에 대해서
- (오메가) = c1 * f(n) <= T(n) <= c2 * f(n) = (빅오)이 되는 상수 c1, c2, n0가 존재할 때만 T(n) = 세타(f(n)) 이라 한다.
- 오메가 <= 세타 <= O

![image-20200429102358005](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429102358005.png)

n은 입력데이터의 갯수이기에 자연수다. 자연수이기에 맞는 조건 없음 1.X

![image-20200429102251158](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429102251158.png)

2번 O

![image-20200429102310207](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429102310207.png)

3번 O

![image-20200429103537235](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429103537235.png)

정답은 : 2 3 4

#### 자주 사용하는 O-표기

| O-표기 | 시간 |
| ------ | ---- |
|        |      |
|        |      |
|        |      |
|        |      |
|        |      |
|        |      |

![image-20200429103620254](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429103620254.png)

- 효율적인 알고리즘은 값비싼 하드웨어의 기술 개발보다 효율적인 알고리즘 개발이 훨씬 더 경제적이다.

### 표준 입출력 방식

![image-20200429103757178](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429103757178.png)

![image-20200429103826928](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429103826928.png)

### 비트 연산

![image-20200429103926210](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429103926210.png)

![image-20200429105248811](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429105248811.png)

![image-20200429105655763](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200429105655763.png)

### 진수

### 실수