# 2020.02.10 알고리즘 월말평가 1

### **[문제1] 명도 필터 적용**

10X10 격자에 0에서 255까지의 명도 단계가 입력되어 있다. 두 개의 필터를 적용하여 명도 단계를 변경하려 한다. A 필터는 명도 단계를 2배의 값으로, B 필터는 반으로 만든다. 그러나 최대 명도 단계는 255, 최소 단계는 0으로, 필터 적용 후 255이상이 되는 경우 255가 된다. 필터는 중복되어 적용되지 않는다. 변경된 명도 단계의 합을 출력하는 프로그램을 작성하시오.

예를 들어 아래와 같은 격자에서

| 13   | 24   | 13   | 24   | 1    | 7    | 224  | 11   | 22   | 18   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 20   | 128  | 29   | 21   | 27   | 13   | 29   | 16   | 6    | 28   |
| 13   | 119  | 200  | 123  | 211  | 1    | 19   | 5    | 5    | 28   |
| 125  | 10   | 20   | 12   | 224  | 129  | 13   | 20   | 18   | 1    |
| 26   | 23   | 24   | 1    | 25   | 8    | 29   | 13   | 11   | 1    |
| 18   | 25   | 26   | 26   | 14   | 27   | 12   | 13   | 73   | 28   |
| 4    | 16   | 6    | 21   | 29   | 20   | 3    | 17   | 23   | 6    |
| 3    | 10   | 14   | 25   | 13   | 24   | 113  | 2    | 24   | 10   |
| 13   | 20   | 27   | 8    | 19   | 21   | 223  | 123  | 2    | 2    |
| 12   | 9    | 7    | 24   | 22   | 17   | 9    | 22   | 4    | 27   |

 

A 필터를 (2, 2, 4, 5)에, B 필터를 (7, 6, 8, 7) 필터 적용 후 

|      | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 13   | 24   | 13   | 24   | 1    | 7    | 224  | 11   | 22   | 18   |
| 1    | 20   | 128  | 29   | 21   | 27   | 13   | 29   | 16   | 6    | 28   |
| 2    | 13   | 119  | 255  | 246  | 255  | 2    | 19   | 5    | 5    | 28   |
| 3    | 125  | 10   | 40   | 24   | 255  | 255  | 13   | 20   | 18   | 1    |
| 4    | 26   | 23   | 48   | 2    | 50   | 16   | 29   | 13   | 11   | 1    |
| 5    | 18   | 25   | 26   | 26   | 14   | 27   | 12   | 13   | 73   | 28   |
| 6    | 4    | 16   | 6    | 21   | 29   | 20   | 3    | 17   | 23   | 6    |
| 7    | 3    | 10   | 14   | 25   | 13   | 24   | 56   | 1    | 24   | 10   |
| 8    | 13   | 20   | 27   | 8    | 19   | 21   | 111  | 61   | 2    | 2    |
| 9    | 12   | 9    | 7    | 24   | 22   | 17   | 9    | 22   | 4    | 27   |

 

결과로 A 필터에 의한 변경 값 470과 B 필터에 의한 변경 값 232의 합인 702를 출력한다. 

 

 

**[입력]**

첫 줄에 테스트 케이스 개수 T가 주어진다. (1<=T<=10)

다음 줄에 A필터의 영역으로 왼쪽 위 모서리 인덱스 r1, c1, 오른쪽 아래 모서리 r2, c2 가 입력되고 다음 줄에 B필터의 영역이 입력된다. 다음 줄부터 10줄에 거쳐 10개씩 격자 자료가 입력된다.

 

 

**[출력]**

명도 변경액의 합을 출력한다.

 

**[입력 예시]**

2

2 2 4 5

7 6 8 7

13 24 13 24 1 7 224 11 22 18

20 128 29 21 27 13 29 16 6 28

13 119 200 123 211 1 19 5 5 28

125 10 20 12 224 129 13 20 18 1

26 23 24 1 25 8 29 13 11 1

18 25 26 26 14 27 12 13 73 28

4 16 6 21 29 20 3 17 23 6

3 10 14 25 13 24 113 2 24 10

13 20 27 8 19 21 223 123 2 2

12 9 7 24 22 17 9 22 4 27

4 5 7 8

1 3 2 7

13 24 13 24 1 7 224 11 22 18

20 128 29 21 27 13 29 16 6 28

13 119 200 123 211 1 19 5 5 28

125 10 20 12 224 129 13 20 18 1

26 23 24 1 25 8 29 13 11 1

18 25 26 26 14 27 12 13 73 28

4 16 6 21 29 20 3 17 23 6

3 10 14 25 13 24 113 2 24 10

13 20 27 8 19 21 223 123 2 2

12 9 7 24 22 17 9 22 4 27

 

**[출력 예시]**

\#1 702

\#2 649

 

```python
T = int(input())
for t in range(T):
    lst = [[0 for _ in range(10)] for _ in range(10)]
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    sum_A1 = 0
    sum_A2 = 0
    sum_B1 = 0
    sum_B2 = 0

    for i in range(10):
        lst[i] = list(map(int, input().split()))

    for i in range(A[2]-A[0]+1):
        for j in range(A[3]-A[1]+1):
            sum_A1 += lst[A[0]+i][A[1]+j]
            lst[A[0] + i][A[1] + j] = lst[A[0]+i][A[1]+j]*2
            if lst[A[0] + i][A[1] + j] > 255:
                lst[A[0] + i][A[1] + j] = 255
            sum_A2 += lst[A[0] + i][A[1] + j]

    for i in range(B[2] - B[0] + 1):
        for j in range(B[3] - B[1] + 1):
            sum_B1 += lst[B[0] + i][B[1] + j]
            lst[B[0] + i][B[1] + j] = int(lst[B[0] + i][B[1] + j] / 2)
            if lst[B[0] + i][B[1] + j] < 1:
                lst[B[0] + i][B[1] + j] = 0
            sum_B2 += lst[B[0] + i][B[1] + j]


    print('#{} {}'.format(t+1, abs(sum_A2-sum_A1)+ abs(sum_B2-sum_B1)))
```



### **[문제2] 페인팅 로봇**

지정한 사각형 공간에 페인트 칠을 하는 로봇이 있다. 로봇은 칠할 평면 전체를 R개의 줄과 줄 당 C개의 칸으로 구분하며, 칠하려는 N개의 사각형 영역 각각에 대해 왼쪽 위(r1, c1)와 오른쪽 아래 칸의 좌표(r2, c2)를 필요로 한다. 

이번 작업은 일단 흰색으로 바탕칠이 된 벽을 한가지 색으로 다시 칠하되, 투명도가 있는 페인트를 적당히 겹쳐 칠해 연하고 진한 영역의 차이를 이용한 무늬를 만들려고 한다. 다만 가장 진한색이 너무 많은 영역을 차지하면 너무 어두워 보일 수 있으므로, 가장 진한색이 되는 칸의 수를 프로그램을 만들어 미리 확인해 보자.

R=4, C=10인 경우 로봇은 다음과 같이 영역을 구분한다.

|      | 1    | 2    | 3    | 4    | 5    | 6    | 7    |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    |      |      |      |      |      |      |      |      |
| 2    |      |      |      |      |      |      |      |      |
| 3    |      |      |      |      |      |      |      |      |
| 4    |      |      |      |      |      |      |      |      |
|      |      |      |      |      |      |      |      |      |

 

다음은 칠할 영역의 개수 N이 3일 때, 각 영역의 왼쪽 위, 오른쪽 아래 모서리의 좌표와 칠해진 결과의 예이다. (각 줄에 왼쪽 위 줄 칸, 오른 쪽 아래 줄 칸 번호)

1 2 2 4 

2 3 4 6

3 6 4 7

|      | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    |      |      |      |      |      |      |      |
| 2    |      |      |      |      |      |      |      |
| 3    |      |      |      |      |      |      |      |
| 4    |      |      |      |      |      |      |      |

 

이경우 두 번 겹쳐 칠해진 칸이 가장 진한색이 되며 같은 색의 전체 칸 수는 4가 된다.

 

**[입력]**

첫 줄에 테스트케이스 개수 T가 주어진다. (1<=T<=10)

다음 줄부터 각 테스트케이스 별로 첫 줄에 R, C, N이, 다음 줄부터 N줄에 걸쳐 칠할 영역의 왼쪽 위와 오른쪽 아래 칸의 좌표 r1, c1, r2, c2가 주어진다.

(1<=R, C<=100, 1<=N<=10, r1<=r2, c1<=c2)

 

**[출력]**

\#과 테스트 케이스 번호, 빈칸에 이어 가장 진하게 칠해진 칸 수를 출력한다.

 

**[입력 예시]**

3

4 7 3

1 2 2 4 

2 3 4 6

3 6 4 7

5 5 3

1 1 5 5

2 2 5 5

3 3 4 4

10 10 5

2 3 5 5

3 4 6 7

5 4 8 7

6 6 8 8

5 5 10 10

 

**[출력 예시]**

\#1 4

\#2 4

\#3 3



```python
T = int(input())
for t in range(T):
    R, C, N = map(int, input().split())
    lst = [[0 for _ in range(C)] for _ in range(R)]

    for _ in range(N):
        color = list(map(int, input().split()))
        for i in range(color[2] - color[0] + 1):
            for j in range(color[3] - color[1] + 1):
                lst[color[0] + i - 1][color[1] + j - 1] += 1


    maxcnt = 0
    result = 0
    for i in range(R):
        for j in range(C):
            if maxcnt < lst[i][j]:
                maxcnt = lst[i][j]
    for i in range(R):
        for j in range(C):
            if lst[i][j] == maxcnt:
                result += 1


    print('#{} {}'.format(t+1,result))
```



### **문제 3: 농작물 수확하기**

입력으로 NXN 크기의 농장에 대한 정보가 2차 배열 형태의 정수 값들로 주어진다. 주어진 정수 값들은 각 셀에서 얻을 수 있는 농작물의 양이다. 

이 농장을 운영하고 있는 3형제는 농장을 3개 구역으로 분할해서 최대한 공평하게 농작물을 나누고 싶어한다.

농장을 3개 구역으로 나누는 방법은 아래 왼쪽 그림과 같이 먼저 가로선과 세로선을 설정해서 4개의 구역으로 나눈다. 그리고, A와 B 구역을 합쳐서 오른쪽 그림과 같이 3개의 구역으로 만든다. 각 구역의 가로와 세로의 크기는 최소 1이상이어야 한다.

​                               

각 구역에 포함된 정수 값들의 총합이 얻을 수 있는 농작물의 총 양이 된다.

구역을 나누는 방법에 따라서 각 구역에서 얻을 수 있는 농작물의 양이 달라 질 것이다.

다음 5 X 5 크기 농장에 대한 정보가 있다. 

| 2    | 3    | 2    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 1    | 1    | 1    | 3    |
| 3    | 2    | 3    | 1    | 3    |
| 1    | 1    | 3    | 2    | 1    |
| 2    | 2    | 2    | 1    | 1    |

| 2    | 3    | 2    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- |
| 3    | 1    | 1    | 1    | 3    |
| 3    | 2    | 3    | 1    | 3    |
| 1    | 1    | 3    | 2    | 1    |
| 2    | 2    | 2    | 1    | 1    |

 

오른쪽과 같이 3구역으로 분할하면 각 구역의 농작물의 양은 12, 19, 16 이 되고, 19 – 12 = 7로 차이가 최소가 된다.

3형제가 최대한 공평하게 농작물을 나눠 가지기 위해, 각 구역의 농작물 양의 최대값과 최소값의 차이가 최소가 되는 경우를 찾아서 차이를 출력해보자.

 

 

**[입력]**

첫 줄에 테스트 케이스 개수 T가 주어진다. ( 1 <= T<= 10 )

각 테스트 케이스 마다 첫 줄에 농장의 크기 N이 주어진다. (5 <= N <= 30)

바로 다음 N개의 줄에 공백으로 구분된 N개의 정수가 주어진다.

각 셀의 농작물의 양은 1이상 3이하의 값이다.

 

**[출력]**

\#과 1번부터인 테스트케이스 번호를 출력하고, 3개 구역에서 획득하는 농장물 양의 최대값과 최소값의 차이의 최소값을 출력한다.

 

**[입력 예시]**

3

5

2 3 2 2 1

3 1 1 1 3

3 2 3 1 3

1 1 3 2 1

2 2 2 1 1

5

3 3 2 1 1

2 1 1 3 1

3 1 3 3 2

3 1 2 2 3

2 3 1 2 2

5

1 3 2 1 3

3 1 3 2 1

3 3 1 1 2

1 3 2 2 1

1 2 3 3 2

 

**[출력 예시]**

\#1 7

\#2 8

\#3 6

 

```python
T = int(input())
for t in range(T):
    N = int(input())
    lst = [[0 for _ in range(N)] for _ in range(N)]
    for i in range(N):
        lst[i] = list(map(int, input().split()))

    result = N * N * N
    for i in range(1, N):
        for j in range(1, N):
            s1 = s2 = s3 = 0
            for row in range(0, i): # 1번 영역
                for col in range(0, j):
                    s1 += lst[row][col]

            for row in range(i, N): # 2번 영역
                for col in range(0, j):
                    s2 += lst[row][col]

            for row in range(0, N): # 3번 영역
                for col in range(j, N):
                    s3 += lst[row][col]
            if result > (max(s1, s2, s3) - min(s1, s2, s3)):
                result = max(s1, s2, s3) - min(s1, s2, s3)

    print('#{} {}'.format(t+1, result))
```



 