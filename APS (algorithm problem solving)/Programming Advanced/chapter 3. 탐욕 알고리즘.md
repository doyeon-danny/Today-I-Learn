# chapter 3. 탐욕(Greedy) 알고리즘

2020.05.07

### 탐욕 알고리즘이란?

- 최적해 구하는데 사용되는 근시안적 방법

- 일반적으로, 머리 속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근!
- 여러 경우 중 하나를 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식을 진행하여 최종적인 해답에 도달함
  - 한번 선택 번복 X ==> 대부분 탐욕 알고리즘 단순, 제한적인 문제에 적용됨
- 각 선택 시점에서 이루어진 결정은 지역적으로 최적이지만 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여 **그것이 최적이라는 보장이 없다!**
- 최적화 문제 (optimization)란 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제

#### 탐욕 알고리즘의 동작 과정

1. **해 선택** : 현재 상태에서 부분 문제의 최적 해를 구한 뒤 부분해집합(Solution Set)에 추가한다.

2. **실행 가능성 검사** : 새로운 부분해 집합이 실행 가능한지 확인한다.

   곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.

3. **해 검사** : 새로운 부분 해 집합이 문제의 해가 되는지를 확인한다.

   아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

#### 탐욕 알고리즘의 필수 요소

- 탐욕적 선택 속성 (greedy choice property)
  - 탐욕적 선택은 최적해로 갈 수 있음을 보여라 => 즉, 탐욕적 선택은 항상 안전하다.
- 최적 부분 구조 (optimal substructure property)
  - 최적화 문제를 정형화하라 => 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.
- **[원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해]** 임을 증명하라.

##### 탐욕 기법 vs 동적 계획법의 비교

일반적 비교 참고정도로 보자. 실제로 설계시에는 딱 정해놓고 쓰기 보단 여러가지 이용가능 하며 작성하며 변경할 수 있기에

|                          탐욕 기법                           |                       동적 계획법                       |
| :----------------------------------------------------------: | :-----------------------------------------------------: |
| 매 단계에서 가장 좋게 보이는 것을 빠르게 선택한다. => 지역 최적 선택 (local optimal choice) | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 한다. |
|     하위 문제를 풀기 전 (탐욕적) 선택이 먼저 이루어진다.     |               하위 문제가 우선 해결된다.                |
|                        Top-down 방식                         |                     Botton-up 방식                      |
|                 일반적으로 빠르고 간결하다.                  |                 좀더 느리고, 복잡하다.                  |

##### 대표적인 탐욕 기법의 알고리즘들

|      알고리즘       |                             목적                             |                             설명                             |        |
| :-----------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----: |
|        Prim         |       N개의 노드에 대한 최소 신장 트리(MST)를 찾는다.        |             서브트리를 확장하면서 MST를 찾는다.              | 그래프 |
|       Kruskal       |                              "                               |     싸아클이 없는 서브 그래프를 확장하면서 MST를 찾는다.     | 그래프 |
|      Dijkstra       |    주어진 정점에서 다른 정점들에 대한 최단 경로를 찾는다.    | 주어진 정점에서 가장 가까운 정점을 찾고 그 다음을 정점을 반복해서 찾는다. | 그래프 |
| Huffman tree & code | 문서의 압축을 위해 문자들의 빈도 수에 따라 코드값을 부여한다. | 출현 빈도가 낮은 문자부터 선택해서 이진 트리를 완성하고 코드값을 부여한다. | 그래프 |

### 배낭 짐싸기 문제 (Knapsack)

도둑은 부자들의 값진 물건들을 훔치기 위해 보관 창고에 침입했다.

도둑은 훔친 물건을 배낭에 담아 올 계획이다. 배낭은 담을 수 있는 물건의 총 무게 (W) 가 정해져 있다.

창고에는 여러 개 (n개) 의 물건들이 있고 각각의 물건에는 무게와 값이 정해져 있다.

경비원들에 발각되기 전에 배낭이 수용할 수 있는 무게를 초과하지 않으면서 값이 최대가 되는 물건을 담아야 한다.

#### Knapsack 문제의 정형적 정의

- S : {item1, item2, ..., itemn}, 물건들의 집합

- wi : itemi의 무게, Pi = itemi의 값

- W : 배낭이 수용 가능한 총 무게

  => 문제 정의 : W 이하를 만족하면서 P가 최대가 되도록 S에 A가 부분집합이 되는 A를 결정하는 문제

#### Knapsack 문제 유형

- 0-1 Knapsack
  - 배낭에 물건을 통째로 담아야 하는 문제
  - 물건을 쪼갤 수 없는 경우
- Fractional Kanpsack
  - 물건을 부분적으로 담는 것이 허용되는 문제
  - 물건을 쪼갤 수 있는 경우

#### 0-1 Knapsack 에 대한 문제 해결 방법

##### 완전 검색 방법

- 완전 검색으로 물건들의 집합 S에 대한 모든 부분집합을 구한다.
- 부분집합의 총 무게가 W를 초과하는 집합들은 버리고, 나머지 집합에서 총 값이 가장 큰 집합을 선택할 수 있다. 
- 물건의 개수가 증가하면 시간 복잡도가 지수적으로 증가한다. (크기n인 부분 집합 : 2^n)

##### 탐욕적 방법

1. 값이 비싼 물건부터 채운다. => 최적 X

2. 무게가 가벼운 물건부터 채운다. => 최적 X

3. 무게당 값이 높은 순서로 물건을 채우기 => 최적 X

   ※ 탐욕적 방법으로 최적해를 구하기 어렵다.

##### cf) Fractional Kanpsack에 대한 문제 해결 방법

무게당 값이 높은 순서로 물건을 채우는 탐욕적 방법을 통해 해결 가능하다.

### 회의실 배정하기

김대리는 소프트웨어 개발팀들의 회의실 사요 신청을 처리하는 업무를 한다. 금요일에 사용 가능한 회의실은 하나만 존재하고 다수의 회의가 신청된 상태이다.

회의는 시작 시간과 종료 시간이 있으며, 회의 시간이 겹치는 회의들은 동시에 열릴 수 없다.

가능한 많은 회의가 열리기 위해서는 회의들은 어떻게 배정해야 할까?

- 입력 예

  ```python
  10 # 회의 개수
  1 4 1 6 6 10 5 7 3 8 5 9 3 5 8 11 2 13 12 14 # (시작시간, 종료시간)
  ```

#### 활동 선택(Activity-selection problem) 문제

- 시작시간과 종료시간(si, fi,)이 있는 n개의 활동들의 집합 A , 1 <= i <= n 에서 서로 겹치지 않는 (non-overlapping) 최대갯수의 활동들의 집합 S를 구하는 문제
- 양립가능한 활동들의 크기가 최대가 되는 So,n+1 의 부분집합을 선택하는 문제
  - 종료 시간 순으로 활동들을 정렬
  - So,n+1: ao의 종료시간 부터 an+1의 시작시간 사이에 포함된 활동들

##### 탐욕 기법의 적용

- 공집합이 아닌 하위 문제(subproblem) Si,j가 있고 Si,j에 속한 활동 am은 종료 시간이 가장 빠른 활동이다.
  1. 하위 문제(subproblem) Si,j에서 종료 시간이 가장 빠른 활동 am을 선택한다.
  2. Si,m은 공집합이므로, am을 선택하면 공집합이 아닌 하위 문제 Sm,i가 남는다.
  3. 1, 2 과정을 반복한다.

##### 탐욕 기법을 적용한 반복 알고리즘

```python
# A : 활동들의 집합, S : 선택된 활동(회의)들의 집합
# si : 시작시간, fi : 종료시간 , 1 <= i <= n

Sort A by finish time
S <- {A1}
j <- 1
for i in range(2, n):
    if si>= fi:
        S = S U {Ai}
        j = i
```

- 종료시간이 빠른 순서로 활동들을 정렬한다.
- 첫번재 활동(A1)을 선택한다.
- 선택한 활동(A1)의 종료시간보다 빠른 시작 시간을 가지는 활동을 모두 제거한다.
- 남은 활동들에 대해 앞의 과정을 반복한다.

##### 재귀 알고리즘

```python
# A : 정렬된 활동들의 집합
# S : 선택된 활동(회의)들 집합
# si : 시작 시간, fi : 종료시간, 0<=i<=n+1

def Recursive_Selection(i, j):
    m = i + 1
    while m < j and sm < fi: # 종료 시간이 가장 빠른 활동 선택
        m = m + 1
    if m < j: return {am} U Recursive_Selection(m, j)
    else: return {} # 공집합
```

### 탐욕 기법을 통한 Baby-gin 문제 해결

- 코드 풀이

  받은 숫자들을 list에 카운트하는 방법

  ```python
  i = 0
  tri = 0 
  run = 0
  inp = input()
  c[12] <- {0, }
  
  while i < 6:
      c[inp%10] = c[inp%10] + 1
      inp = inp // 10
      i += 1
  i = 0
  while i < 10:
      if c[i] >= 3:
          c[i] = c[i] - 3
          tri += 1
      if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
          c[i] -= 1
          c[i+1] -= 1
          c[i+2] -= 1
          run += 1
          continue
      i += 1
  ```

  

