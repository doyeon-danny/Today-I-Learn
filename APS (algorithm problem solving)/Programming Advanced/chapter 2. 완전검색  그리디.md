# chapter 2. 완전검색 / 그리디

2020.05.06

> 학습 목표
>
> - 재귀적 알고리즘의 특성 이해, 이를 구현하기 위한 재귀 호출에 대해 학습
> - 완전 검색의 개념 이해, 완전 검색을 통한 문제 해결 방법에 대해 학습
> - 조합적 문제 (Combinatorial Problems)에 대한 완전 검색 방법에 대해 이해
>   - 순열, 조합, 부분집합을 생성하는 알고리즘 학습
> - 탐욕 알고리즘 기법의 개념과 주요 특성 이해

### 반복(Iteration)과 재귀(Recursion)

- 반복과 재귀는 유사한 작업 수행 가능
- 반복은 수행하는 작업이 완료될 때까지 계속 반복 → 루프 (for, while 구조)
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합
  - 재귀 함수로 구현

#### 반복 구조

1. 초기화 → (조건검사 → 명령문 실행 → 업데이트) 괄호를 반복하다 조건검사를 통해 끝남  
2. 초기화 → (명령문 실행 → 업데이트 → 조건검사) 괄호를 반복하다 조건검사를 통해 끝남

- 초기화 : 반복되는 명령문 실행 전(한번만) 조건 검사에 사용할 변수의 초기값 설정
- 조건 검사 (check control expression)
- 반복할 명령문 실행 (action)
- 업데이트 (loop update) : 무한 루프 (infinite loop) 가 되지 않게 조건이 거짓(false)이 되게 함.

```python
# 반복을 이용한 선택 정렬
def SelectionSort(A):
    n = len(A)
    for i in range(0, n-1):
        min = i
        for j in range(i+1, n):
            if A[j] < A[min]:
                min = j
        A[min], A[i] = A[i], A[min]
```

#### 재귀적 알고리즘

- 재귀적 정의는 두 부분으로 나뉜다.

  1. 하나 또는 그 이상의 기본 경우 (basic case or rule)

     집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드(seed) 역할

     스택 overflow 방지, 기초가 되는 부분

  2. 하나 또는 그 이상의 유도된 경우 (inductive case or rule)

     새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

#### 재귀 함수 (recursive function)

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수

- 일반적으로 재귀적 정의를 이용해서 재귀 함수를 구현

- **기본 부분(basic part)**와 **유도 부분(inductive part)**로 구성

- 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉬움

- 함수 호출은 프로그램 메모리 구조에서 스택을 사용

  재귀 호출은 반복적인 스택의 사용을 의미, 메모리 및 속도에 성능 저하 발생

  `호출 → 호출 → ... return → return ... : 프로그램 메모리 구조`

##### 펙토리얼 재귀 함수

- 재귀적 정의

  - Basic rule : N <= 1인 경우 n = 1

  - Inductive rule : N > 1, n! = n X (n-1)!

    ```python
    def fact(n):
        if n<= 1: return 1 # Basic part
        else: return n * fact(n-1) # Inductive part
    ```

#### 반복 vs 재귀

- 해결할 문제를 고려해서 반복이나 재귀의 반복 선택
- 재귀는 문제 해결을 위한 알고리즘 설계가 간단하고 자연스러움.
  - 추상 자료형(List, tree 등)의 알고리즘은 재귀적 구현이 간단하고 자연스러운 경우가 많음.
- 일반적으로 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산이 필요로 한다.

※ 입력 값이 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다!

|                    |                        재귀                        |          반복          |
| :----------------: | :------------------------------------------------: | :--------------------: |
|      **종료**      | 재귀 함수 호출이 종료되는 베이스 케이스(base case) |   반복문의 종료 조건   |
|   **수행 시간**    |                   (상대적) 느림                    |          빠름          |
|  **메모리 공간**   |                 (상대적) 많이 사용                 |       적게 사용        |
| **소스 코드 길이** |                     짧고 간결                      |          길다          |
| **소스 코드 형태** |              선택 구조 (if ... else)               | 반복 구조 (for, while) |
|  **무한 반복시**   |                  스택 오버플로우                   |  CPU를 반복해서 점유   |

##### 2^k 연산에 대한 재귀와 반복

- 재귀

  ```python
  def Power_of_2(k): # Output : 2^k
      if k == 0:
          return 1
      else:
          return 2 * Power_of_2(k-1)
  ```

- 반복

  ```python
  def Power_of_2(k): # Output : 2^k
      i = 0
      power = 1
      while i < k:
          power *= 2
          i += 1
      return power
  ```

#### 연습문제 1

선택 정렬 함수 (SelecionSort)를 재귀적 알고리즘으로 작성해 보시오.

- 풀이 point

  basic 부분 : unsorted 부분이 1이 될 경우

  Inductive  부분 : sort, unsorted 부분 나누기, unsorted 부분 점점 줄어들도록!, unsorted 부분에서 가장 작은것을 앞으로 정렬하기

- 풀이 코드

  ```python
  def SelectionSort(A, s):
      n = len(A)
      if s == n-1: return
      min = s
      for i in range(s, n):
          if A[min] > A[i]:
              min = i
      A[s], A[min] = A[min], A[s]
      SelectionSort(A, s+1)
  
  
  A = [2, 4, 6, 1, 9, 8, 7, 0]
  SelectionSort(A, 0)
  print(A) # [0, 1, 2, 4, 6, 7, 8, 9]
  ```

### 완전검색기법

#### 완전 검색

- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것이다.

- 전형적으로 순열(Permutation), 조합(Combination), 부분집합(subsets)과 같은 조합적 문제들(Combinatorial Problems)과 연관된다.

→ 완전 검색은 `조합적 문제에 대한 brute-force 방법`이다.

- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
  - 완전 검색은 입력의 크기를 작게 해서 간편하고 빠르게 답을 구하는 프로그램을 작성한다.
- 이를 기반으로 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있다.
- 검정등에서 주어진 문제를 풀 때, 우선 **완전 검색으로 접근하여 해답을 도출**한 후, **성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인**하는 것이 바람직하다.

#### 고지식한 방법 (brute-force)

- brute-force : 문제 해결을 위한 간단하고 쉬운 접근법
  - "Just do it"
  - force : 사람(지능)보다 컴퓨터의 force 의미
- brute-force 방법은 대부분의 문제에 적용 가능하다.
- 상대적으로 빠른 시간에 문제 해결(알고리즘 설계)를 할 수 있다.
- 문제에 포함된 자료(요소, 인스턴스)의 크기가 작다면 유용하다.
- 학술적 또는 교육적 목적을 위해 알고리즘의 효율성을 판단하기 위한척도로 사용된다.

##### Brute-force 탐색 (sequential search)

- 자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행한다.

- 결과

  - 탐색 성공 / 탐색 실패

  ```python
  def SequentialSearch(A[0, ..., n], k):
      A[n] = k
      i = 0
      while A[i] != k:
          i += 1
      if i < n: return i
      else: return 1
  ```

#### 문제 제시 : Baby-gin Game

- 0 ~ 9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적이 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
- 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin으로 부른다. 
- 6자리의 숫자를 입력받아 baby-gin 여부를 판단하는 프로그램을 작성하라.

- 입력 예

  - 667767은 두 개의 triplet이므로 baby-gin이다. (666, 777)
  - 054060은 한 개의 run과 한 개의 triplet이므로 baby-gin이다. (456, 000)
  - 101123은 한 개의 triplet만 존재하므로 baby-gin이 아니다.

  ---

- 완전 검색을 통한 Baby-gin 접근

  1. 고려할 수 있는 모든 경우의 수 생성하기

     6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)

     순열을 생성한다.

  2. 해답 테스트하기

     앞의 3자리와 뒤의 3자리를 잘라, run와 triplet 여부를 테스트하고 최종적으로 baby-gin을 판단한다.

### 조합적 문제

### 탐욕 알고리즘



