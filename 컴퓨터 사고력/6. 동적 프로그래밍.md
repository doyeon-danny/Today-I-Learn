# 동적 프로그래밍

2020.04.24

### intro

- 간단히 보면 재귀 함수에서 동일한 입력의 함수 호출이 **반복적으로 일어날 때** 그 결과 값을 저장해 두고 불러 쓰는 것! `Memoization`
- 최조 입력에서 파생되는 모든 가능한 입력에 대한 답을 모두 저장할 수 있는 메모리가 있어야 한다.
- 단순히 재귀에서 저장된 값을 찾아보는 것으로도 가능하지만, 결과값을 순서를 정해서 계산할 수도 있다. => `Dynamic Programming, 동적 계획법, 동적 프로그래밍`

### 연습 문제

문제들을 푸는 동적 프로그래밍 알고리즘을 수도코드로 작성하고, 정확성 증명 및 시간 복잡도 계산을 수행하라.

- 문제 1: Memoization 피보나치 수열 : F(n) = F(n-1) + F(n-2), F(1) = F(2) = 1

  (힌트 : 계산되는 값이 n 가지 밖에 없으므로 이 값들을 저장할 수 있는 배열을 만들어 두고 재귀 호출에 들어가기 전에 값이 있는 지 확인하는 방법) 

  ![image-20200424121254185](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200424121254185.png)

  ![image-20200424121327044](C:\Users\youbi\AppData\Roaming\Typora\typora-user-images\image-20200424121327044.png)

- 문제 2: Dynamic Programming 피보나치 수열: F(n) = F(n-1) + F(n-2)

  (힌트 : 작은 값부터 순서대로 계산한다.)

  ```python
  Fibonacci(n)
  {
      F[0] = 0
      F[1] = 1
      
      for i in range(2, n+1):
      	F[i] = F[i-1] + F[i-2]
      
      return F[n]
  }
  ```

  시간 복잡도 : O(n)

- 질문 : 실제로 실행시키면 세 버전 중 어느 것이 가장 빠를 것으로 예상되는가

  - **재귀 : O(2^n)**
  - **메모리제이션 : O(n)**, 복잡도는 dp와 같지만 재귀함수로 인한 시간이 다소 걸리기에 dp가 더 바름
  - **dp : O(n)**
  - 답 : 동적 계획법